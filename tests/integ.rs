#[cfg(feature = "integ-tests")]
mod testshell;
#[cfg(feature = "integ-tests")]
mod integ_tests {
    extern crate chan_signal;
    extern crate pty;
    extern crate tempdir;
    use super::testshell::TestShell;
    use std::thread;
    use self::tempdir::TempDir;
    use std::sync::mpsc;
    use std::process::Command;
    use std::os::unix::process::CommandExt;
    use std::path::{Path, PathBuf};
    use std::fs;
    use std::io::Write;
    use std::io::Read;
    use std::env;
    use std::time::Duration;
    use std::thread::sleep;

    fn pazi_bin() -> PathBuf {
        // target/.../deps/integ...
        let mut pazi = env::current_exe().unwrap();
        pazi.pop(); // integ-... bin
        pazi.pop(); // deps folder
        pazi
    }

    #[test]
    fn it_jumps() {
        it_jumps_shell("zsh");
        it_jumps_shell("bash");
    }

    fn it_jumps_shell(shell: &str) {
        let mut h = Harness::new(&pazi_bin().join("pazi"), shell);

        h.create_dir("/tmp");
        h.visit_dir("/tmp");
        assert_eq!(h.jump("tmp"), "/tmp");
    }

    #[test]
    fn it_jumps_to_more_frecent_items() {
        it_jumps_to_more_frecent_items_shell("zsh");
        it_jumps_to_more_frecent_items_shell("bash");
    }
    fn it_jumps_to_more_frecent_items_shell(shell: &str) {
        let mut h = Harness::new(&pazi_bin().join("pazi"), shell);

        h.create_dir("/a/tmp");
        h.create_dir("/b/tmp");
        // Visiting 'b' more recently means it shouldbe more frecent.
        h.visit_dir("/a/tmp");
        sleep(Duration::from_millis(5));
        h.visit_dir("/b/tmp");
        assert_eq!(h.jump("tmp"), "/b/tmp");

        // Visiting 'a' more often should make it more 'frecent'
        for _ in 0..10 {
            h.visit_dir("/a/tmp");
        }
        h.visit_dir("/b/tmp");
        assert_eq!(h.jump("tmp"), "/a/tmp");
    }

    struct Harness {
        root: PathBuf,
        testshell: TestShell,
    }

    impl Harness {
        fn new(pazi: &Path, shell: &str) -> Self {
            let ps1 = "==PAZI==> ";
            let root = TempDir::new("pazi_integ").unwrap().into_path();
            let home = Path::new(&root).join("home/pazi");
            // We have to create the shellrc before spawning the shell. Since the shell is spawned
            // across a fork, mpsc channels won't work, so just create the rc before (even though
            // h.create_dir would be convenient to call, oh well).
            fs::create_dir_all(&home).unwrap();
            let shellrc = Path::new(&root).join(format!("home/pazi/.{}rc", shell));
            let mut rc = fs::File::create(shellrc).unwrap();
            rc.write_all(
                format!(
                    r#"#Autogenerated by pazi integ tests
set -e
export PS1="{2}" # sep so we know when our commands finished
export PATH=$PATH:$(dirname "{0}")
eval "$("{0}" --init {1})"
"#,
                    pazi.to_str().unwrap(),
                    shell,
                    ps1,
                ).as_bytes(),
            ).unwrap();

            let mut cmd = Command::new(shell);
            cmd.env("HOME", &home);
            let testshell = TestShell::new(cmd, ps1);
            Harness {
                root: root,
                testshell: testshell,
            }
        }

        fn create_dir(&self, path: &str) {
            let p = Path::new(&self.root).join(Path::new(path).strip_prefix("/").unwrap());
            fs::create_dir_all(p).unwrap();
        }

        fn visit_dir(&mut self, path: &str) {
            let p = Path::new(&self.root).join(Path::new(path).strip_prefix("/").unwrap());
            self.testshell
                .run(&format!("cd '{}'", p.to_string_lossy().to_string()));
        }

        fn jump(&mut self, search: &str) -> String {
            self.testshell
                .run(&format!("z '{}' && pwd", search))
                .trim_left_matches(self.root.to_str().unwrap())
                .to_string()
        }
    }

    impl Drop for Harness {
        fn drop(&mut self) {
            self.testshell.shutdown();
            fs::remove_dir_all(&self.root).unwrap();
        }
    }
}

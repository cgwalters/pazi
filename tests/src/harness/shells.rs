use std::path::Path;
use harness::autojumpers::Autojumper;
use std::fs;
use std::io::Write;
use std::process::Command;

pub enum Shell {
    Bash,
    Zsh,
    Conch,
}

impl Shell {
    pub fn name(&self) -> &'static str {
        match self {
            &Shell::Bash => "bash",
            &Shell::Zsh => "zsh",
            &Shell::Conch => unimplemented!(),
        }
    }

    pub fn from_str(name: &str) -> Self {
        match name {
            "bash" => Shell::Bash,
            "zsh" => Shell::Zsh,
            _ => unimplemented!(),
        }
    }

    pub fn setup(&self, root: &Path, autojump: &Autojumper, ps1: &str) {
        let rc_file = match *self {
            Shell::Bash | Shell::Zsh => root.join(format!("home/pazi/.{}rc", self.name())),
            Shell::Conch => unimplemented!(),
        };

        let rc_template = match *self {
            Shell::Bash => format!(
                r#"#Autogenerated by pazi integ tests
set -e
export PS1="{2}" # sep so we know when our commands finished
export PATH=$PATH:$(dirname "{0}")
{1}
"#,
                autojump.bin_path(),
                autojump.init_for(self),
                ps1
            ),
            Shell::Zsh => format!(
                r#"#Autogenerated by pazi integ tests
set -e
unsetopt zle
export PS1="{2}" # sep so we know when our commands finished
export PATH=$PATH:$(dirname "{0}")
{1}
"#,
                autojump.bin_path(),
                autojump.init_for(self),
                ps1
            ),
            Shell::Conch => unimplemented!(),
        };

        fs::create_dir_all(root.join("home/pazi")).unwrap();
        fs::File::create(rc_file)
            .unwrap()
            .write_all(rc_template.as_bytes())
            .unwrap();
    }

    pub fn command(&self, root: &Path) -> Command {
        let mut cmd = Command::new(self.name());
        cmd.env_clear();
        cmd.env("HOME", root.join("home/pazi"));
        cmd
    }
}

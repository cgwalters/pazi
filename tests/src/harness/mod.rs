extern crate tempdir;

mod testshell;

use std::path::{Path, PathBuf};
use self::tempdir::TempDir;
use self::testshell::TestShell;
use std::process::Command;
use std::io::Write;
use std::fs;

pub struct Harness {
    root: PathBuf,
    testshell: TestShell,
}

impl Harness {
    pub fn new(pazi: &Path, shell: &str) -> Self {
        let ps1 = "==PAZI==> ";
        let root = TempDir::new("pazi_integ").unwrap().into_path();
        let home = Path::new(&root).join("home/pazi");
        // We have to create the shellrc before spawning the shell. Since the shell is spawned
        // across a fork, mpsc channels won't work, so just create the rc before (even though
        // h.create_dir would be convenient to call, oh well).
        fs::create_dir_all(&home).unwrap();
        let shellrc = Path::new(&root).join(format!("home/pazi/.{}rc", shell));
        let mut rc = fs::File::create(shellrc).unwrap();
        rc.write_all(
            format!(
                r#"#Autogenerated by pazi integ tests
set -e
export PS1="{2}" # sep so we know when our commands finished
export PATH=$PATH:$(dirname "{0}")
eval "$("{0}" init {1})"
"#,
                pazi.to_str().unwrap(),
                shell,
                ps1,
            ).as_bytes(),
        ).unwrap();
        let mut cmd = Command::new(shell);
        cmd.env_clear();
        cmd.env("HOME", &home);
        let testshell = TestShell::new(cmd, ps1);
        Harness {
            root: root,
            testshell: testshell,
        }
    }

    pub fn create_dir(&self, path: &str) {
        let p = Path::new(&self.root).join(Path::new(path).strip_prefix("/").unwrap());
        fs::create_dir_all(p).unwrap();
    }

    pub fn visit_dir(&mut self, path: &str) {
        let p = Path::new(&self.root).join(Path::new(path).strip_prefix("/").unwrap());
        self.testshell
            .run(&format!("cd '{}'", p.to_string_lossy().to_string()));
    }

    pub fn visit_dirs(&mut self, paths: &Vec<String>) {
        let cmd = paths
            .iter()
            .map(|el| {
                format!(
                    "cd '{}'",
                    Path::new(&self.root)
                        .join(Path::new(el).strip_prefix("/").unwrap())
                        .to_string_lossy()
                        .to_string()
                )
            })
            .collect::<Vec<_>>()
            .join(" && ");
        self.testshell.run(&cmd);
    }

    pub fn jump(&mut self, search: &str) -> String {
        self.testshell
            .run(&format!("z '{}' && pwd", search))
            .trim_left_matches(self.root.to_str().unwrap())
            .to_string()
    }
}

impl Drop for Harness {
    fn drop(&mut self) {
        self.testshell.shutdown();
        fs::remove_dir_all(&self.root).unwrap();
    }
}

mod testshell;

use std::path::Path;
use self::testshell::TestShell;
use std::process::Command;
use std::io::Write;
use std::fs;
use std::env;

pub struct Harness {
    testshell: TestShell,
}

impl Harness {
    pub fn new(root: &Path, pazi: &Path, shell: &str) -> Self {
        let ps1 = "==PAZI==> ";
        let home = Path::new(&root).join("home/pazi");
        // We have to create the shellrc before spawning the shell. Since the shell is spawned
        // across a fork, mpsc channels won't work, so just create the rc before (even though
        // h.create_dir would be convenient to call, oh well).
        fs::create_dir_all(&home).unwrap();
        let shellrc = Path::new(&root).join(format!("home/pazi/.{}rc", shell));
        let mut rc = fs::File::create(shellrc).unwrap();
        rc.write_all(
            format!(
                r#"#Autogenerated by pazi integ tests
set -e
export PS1="{2}" # sep so we know when our commands finished
export PATH=$PATH:$(dirname "{0}")
eval "$("{0}" init {1})"
"#,
                pazi.to_str().unwrap(),
                shell,
                ps1,
            ).as_bytes(),
        ).unwrap();
        let mut cmd = Command::new(shell);
        cmd.env_clear();
        cmd.env("HOME", &home);
        let testshell = TestShell::new(cmd, ps1);
        Harness {
            testshell: testshell,
        }
    }

    pub fn create_dir(&self, path: &str) {
        fs::create_dir_all(path).unwrap();
    }

    pub fn visit_dir(&mut self, path: &str) {
        self.testshell.run(&format!("cd '{}'", path));
    }

    pub fn visit_dirs(&mut self, paths: Vec<&str>) {
        let cmd = paths
            .iter()
            .map(|el| format!("cd '{}'", el,))
            .collect::<Vec<_>>()
            .join(" && ");
        self.testshell.run(&cmd);
    }

    pub fn jump(&mut self, search: &str) -> String {
        self.testshell
            .run(&format!("z '{}' && pwd", search))
            .to_string()
    }
}

impl Drop for Harness {
    fn drop(&mut self) {
        self.testshell.shutdown();
    }
}
